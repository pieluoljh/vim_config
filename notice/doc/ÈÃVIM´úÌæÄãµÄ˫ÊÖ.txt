.(英文句号) - 简单，快捷 
.（英文句号） 用于实现最简单的重复工作。原理上，vim会记住你最近一次“编辑动作”，使用.（英文句号）可以回放之。要注意的是，“进入插入模式，然后作若干修改，最后离开编辑模式” 被认为是 1 次编辑动作，譬如说，你现在处于正常模式，然后你按i进入插入模式，接着你敲击键盘，输入了“hello”，最后你按Esc回到正常模式，那么，vim记住了你最近的一次编辑动作是”你按下i开始直到你按下Esc为止的所有击键序列“。 

用一个例子说明 . 的用法： {{{1
假设你需要将当前文件中的所有 teh 替换成 the。正常模式下，你输入 /\<teh\>，回车，光标跳到了第一个最近的“teh”的t上。你按下i，然后按3次delete键，然后输入the，然后按esc回到正常模式。接着，你按下n，光标跳到了下一个最近的“teh”，然后你按 . ，看，那个teh马上被替换成the了。于是，你重复地按下n和.，直到所有的teh都被替换完。 
}}}
===================

s - 智力游戏，趣味盎然 
s命令（全称为substitute）是一个非常非常非常（省略若干个非常）有用的命令，配合vim神速的正则匹配，绝对是你居家旅行，杀人越货之必备良品。 

s命令的格式是： 
:[range]s/{pattern}/{string}/[flags] [count] 
其中，pattern 是要匹配的正则表达式，如果留空则表示和上一次s命令使用相同的正则表达式。而string则是要替换的字符串。 
各个参数的含义请客官自行:h :s 
如果要重复上一次的s命令，只需要简单地输入":s", 然后回车。 

要用好s命令，首先要学会使用正则表达式。 
组成正则表达式的常用元素有(来自vim-help手册)： 

^ 匹配行首，也就是一行里的第一个字符前面的“夹缝” 
$ 匹配行尾，也就是一行里的最后一个字符后面的“夹缝”，“夹缝”后面跟着换行符或者文件的结束处。 
\zs 匹配任何位置，并将匹配起始处置于该处: 下一个字符将是整个匹配的第一个字符。 
\ze 匹配任何位置，并将匹配结尾处置于该处: 前一个字符将是整个匹配的最后一个字符。 


\%$ 匹配文件尾。当用于一个字符串时，匹配字符串结束处。 
\%23l 匹配指定的行。 
\%23c 匹配指定的列。 
\%23v 匹配指定虚拟列。 


. 匹配除换行符以外的任何字符 
\n 匹配行尾符 
\s 空白字符； <Space> 和 <Tab> 
\S 非空白字符：\s 之反 
\d 数位: [0-9] 
\D 非数位: [^0-9] 
\x 十六进制数位: [0-9A-Fa-f] 
\X 非十六进制数位: [^0-9A-Fa-f] 
\o 八进制数位: [0-7] 
\O 非八进制数位: [^0-7] 
\w 单词字符: [0-9A-Za-z_] 
\W 非单词字符: [^0-9A-Za-z_] 
\h 单词首字符: [A-Za-z_] 
\H 非单词首字符: [^A-Za-z_] 
\a 英文字母字符: [A-Za-z] 
\A 非英文字母字符: [^A-Za-z] 
\l 小写字符: [a-z] 
\L 非小写字符: [^a-z] 
\u 大写字符: [A-Z] 
\U 非大写字符 [^A-Z] 


* 匹配 0 或更多个前面的匹配原，尽可能多地匹配。 
\+ 匹配一个或更多前面的匹配原。尽可能多。 
\= 匹配 0 或 1 个前面的匹配原。尽可能多。 
\{n,m} 匹配 n 至 m 个前面的匹配原。尽可能多 
\{n} 匹配 n 个前面的匹配原 
\{n,} 匹配至少 n 个前面的匹配原。尽可能多 
\{,m} 匹配 0 至 m 个前面的匹配原。尽可能多 
\{-n,m} 匹配 n 至 m 个前面的匹配原。尽可能少 
\{-n} 匹配 n 个前面的匹配原 
\{-n,} 匹配至少 n 个前面的匹配原。尽可能少 
\{-,m} 匹配 0 至 m 个前面的匹配原。尽可能少 
\{-} 匹配 0 个以上前面的匹配原。尽可能少 


\(\) 一个由转义的括号括起来的模式。例："\(^a\)" 匹配行首的 'a'。 
\%(\) 一个由转义的括号括起来的模式。类似 \(\)，但不算作一个子表达式。这样做允许使用更多的群组，并且处理时会稍快些。 


还有许多神奇的东西，请客官自行:h 

其次，string有一些特殊的可用元素： 
& 替换为完整的匹配 
\0 同上 
\1 替代为匹配的第一个 () 里面的内容 
... 
\9 替代为匹配的第九个 () 里面的内容 
~ 替代为前一个 substitute 的替代字符串(你要知道，当你将string留空时，其实是会删除被匹配的字符串) 
\u 下一个字符成为大写 
\U 其后字符成为大写，直到 \e 出现 
\l 下一个字符成为小写 
\L 其后字符成为小写，直到 \e 出现 
\e 结束 \u、\U、\l 和 \L (注意: 不是 <Esc>!) 
\r 把该行在此位置一分为二 
\b 插入一个 <BS> 
\t 插入一个 <Tab> 
\\ 插入单个反斜杠 


要注意的是，在pattern里，行尾符是用 \n 表示的，而在string里，行尾符是用 \r 来表示！ 
还有许多神奇的东西，请客官自行:h 

接着，要提到一个异常强大的替换技巧：\= 使用表达式的计算结果来生成替换 
当 string 以\=开头，那么string的剩余部分将被看成是一个表达式，vim会计算该表达式，然后将结果作为替换字符串。 
在该表达式中，可以使用函数submatch(n) 来获取第n个子匹配，也就是说，submatch(0) 等于 \0，submatch(1)等于 \1，以此类推。 
如果 表达式的返回值是一个 list，那么相当于返回了一个以换行符连接该list的元素的字符串，例如 如果返回值是 [1, "abc", 0]，相当于返回值 "1\rabc\r0" 
举个例子说，我们有时候会需要生成类似于下面这种数字序列： 
5 
6 
7 
... 
100 
在vim里，要生成这个序列，有很多种方法，其中一种是： 
:s/^/\=range(5, 100) 
类似地，可以生成步进为2的： 
:s/^/\=range(5, 100, 2) 


最后是使用s命令的例子： 
vim并没有提供“保存文件时保证文件以换行符结束”这个选项，但是我们自己可以用自动命令和s命令做一个。在你的.vimrc里加上下面这句 
autocmd BufWritePre * sil $s/.$/&\r/e 
其中， 
autocmd BufWritePre * 表示后面的动作发生具有任何名字的文件保存之前 
sil 表示后面的动作以静默方式执行（没有反馈消息） 
$s/.$/&\r/e 第一个$表示这个s命令的应用范围只是文件的最后一行，然后 .$ 表示匹配一个在行尾前面的字符，而 &\r表示替换为“完整匹配后跟一个换行符”，e 表示即使找不到匹配，也不会产生错误消息 

这个s命令的思路是：假设文件尾不是以换行符结束，那么文件的最后一行必然是非空行（长度非0的行），那么，我们可以为文件最后一行添加一个换行符:) 

类似地，我们可以使用s命令和自动命令来让vim在我们保存文件之前做特定的”修饰“： 
"保存文件时自动删除行尾空格或Tab 
au BufWritePre * sil %s/\s\+$//e 
"自动为文件加上最后修改时间 
au BufWritePre * exe 'sil! 1,' . min([line('$'), 20]) . 's/^\S\+\s\+Last modified: \zs.*/\=strftime("%y-%m-%d %H:%M:%S")/e' 
"删除文件尾多余的空行 
au BufWritePre * %s/^$\n\+\%$//ge 

==================

宏 - 善待你的脑细胞 
有时候，对于一些实现思路并不那么明显的处理，使用s命令会杀死很多无辜的脑细胞，于是，本着KISS原则，我们可以使用宏来实现重复。 
宏的使用很简单，自行 :h 就行。记住@@是重复上一次宏。 
有两个技巧可以令宏作用在连续的若干行： 
1，如果一个宏结束后，光标最终停留在宏开始时的那一行的下一行，那这个宏可以用来对连续行进行操作。 
2，使用normal @a 命令可以令宏作用在若干连续行(a为任意寄存器)。 

最后还是举个简单的例子吧，例如，我们有一个包含100行的文件： 
1 
2 
... 
100 

我们想要将它们变成： 
.\img\1.gif 
.\img\2.gif 
... 
.\img\100.gif 

首先，我们将光标移到第一行，按qq，进入宏录制，按^，光标跳到了行首，按i，键入.\img\，按esc，按$，光标跳到了行尾，按a，键入.gif，按esc，按q，结束宏录制并回到正常模式。 
然后，我们按冒号:，输入 2,100normal @q，回车。 
就算你刚睡醒，这个方法依然有效，因为一切都是那么简单直接。 
同样的效果，如果我们使用s命令： 
:%s/.*/.\\img\\&.gif 

==============

g - 最终boss 
很多命令都支持”行范围“，但是行范围一般只可以表示连续的若干行，如果我们需要只对”符合某种条件“的行进行批量操作，行范围就无能为力了，而g命令则可以做到这一点。 
g命令的一般格式是: 
:[range]g/{pattern}/[cmd] 

这么牛逼的东西，只有:h才能说明白。 
要注意的是，g的默认range是全文件，而不是当前行。而且，cmd可以是任何命令，注意，是”任何“！，也就是说，你甚至可以在cmd里使用s命令，normal命令，从而达到很多神奇的效果。 

例如，要消除连续的重复行可以这样： 
:g/^\(.*\)\n\1$/d 

更多的g命令和s命令的例子，可以参考： 
http://www.rayninfo.co.uk/vimtips.html 

===================

递归map, windo, bufdo, tabdo, argdo - 多文件的批处理 
用法很简单，请自行:h。 

===============

假设要生成1至100间的所有奇数， 

s命令： 
:%s/^/\=range(1,100,2) 
:%s/^/\=line('.') * 2 - 1 

表达式寄存器(这应该是最简单的方法了)： 
在插入模式下，输入 <C-R>=range(1,100,2)，回车 

宏： 
先修改第一行的内容为"1"。正常模式下，光标移到第一行，录制宏： 
qqyyp<c-a><c-a>q 
然后重复这个宏50次：50@q 

用g命令: 
:let i=1 
:g/^/s/^/\=i | let i = i + 2
.
